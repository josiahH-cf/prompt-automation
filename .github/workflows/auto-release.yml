name: Auto Release

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'CHANGELOG.md'
      - 'README.md'
      - '.github/**'
      - 'docs/**'

jobs:
  bump-and-publish:
    if: github.repository_owner == 'josiahH-cf'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    env:
      PYTHONUNBUFFERED: '1'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install build twine

      - name: Determine next version (with prerelease support)
        id: ver
        run: |
          import re, pathlib, subprocess, os
          py = pathlib.Path('pyproject.toml').read_text()
          m = re.search(r"version\s*=\s*['\"]([^'\"]+)['\"]", py)
          cur = m.group(1)
          base_cur = cur.split('-')[0]
          maj,min,patch = [int(x) for x in base_cur.split('.')[:3]]
          logs = subprocess.check_output(['git','log','-n','30','--pretty=%s']).decode()
          level = 'patch'
          if '[major]' in logs: level='major'
          elif '[minor]' in logs: level='minor'
          if level=='major': maj,min,patch = maj+1,0,0
          elif level=='minor': min,patch = min+1,0
          else: patch += 1
          base_new = f"{maj}.{min}.{patch}"
          pre_label = None
          for lbl in ('rc','beta','alpha'):
            if f'[{lbl}]' in logs:
              pre_label = lbl
              break
          new_version = base_new
          is_prerelease = 'false'
          if pre_label:
            tags = subprocess.check_output(['git','tag','--list', f'v{base_new}-{pre_label}.*']).decode().splitlines()
            nums = []
            for t in tags:
              parts = t.rsplit('.',1)
              if len(parts)==2 and parts[0].endswith(f'-{pre_label}'):
                try: nums.append(int(parts[1]))
                except: pass
            next_n = (max(nums)+1) if nums else 1
            new_version = f"{base_new}-{pre_label}.{next_n}"
            is_prerelease = 'true'
          with open(os.environ['GITHUB_OUTPUT'],'a') as fh:
            fh.write(f"new={new_version}\n")
            fh.write(f"is_prerelease={is_prerelease}\n")
          print(f"Current={cur} Next={new_version} (pre={is_prerelease})")

      - name: Run release helper
        env:
          GIT_AUTHOR_NAME: github-actions
          GIT_AUTHOR_EMAIL: actions@github.com
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: actions@github.com
        run: |
          python scripts/release.py --set ${{ steps.ver.outputs.new }} --tag

      - name: Build artifacts
        run: python -m build

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: python -m twine upload --skip-existing dist/*

      - name: Extract release notes from CHANGELOG
        id: notes
        env:
          VER: ${{ steps.ver.outputs.new }}
        run: |
          import pathlib, os
          ver = os.environ['VER']
          cl = pathlib.Path('CHANGELOG.md').read_text(encoding='utf-8').splitlines()
          start = None
          for i,l in enumerate(cl):
            if l.startswith(f'## {ver} '):
              start = i
              break
          notes_lines = []
          if start is not None:
            i = start+1
            while i < len(cl) and not cl[i].startswith('## '):
              notes_lines.append(cl[i])
              i += 1
          notes = '\n'.join(notes_lines).strip() or 'No notable changes.'
          notes_escaped = notes.replace('%','%25').replace('\n','%0A')
          with open(os.environ['GITHUB_OUTPUT'],'a') as fh:
            fh.write(f"body={notes_escaped}\n")

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.ver.outputs.new }}
          release_name: v${{ steps.ver.outputs.new }}
          body: ${{ steps.notes.outputs.body }}
          prerelease: ${{ steps.ver.outputs.is_prerelease }}

      - name: Push changes & tags
        run: |
          git push origin HEAD:main
          git push origin --tags

      - name: Summary
        run: echo "Released version ${{ steps.ver.outputs.new }} (prerelease=${{ steps.ver.outputs.is_prerelease }})"
